// This file is part of meshoptimizer library and is distributed under the terms of MIT License.
// Copyright (C) 2016-2019, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
var assert = require('assert').strict;
var decoder = require('./meshopt_decoder.js');

process.on('unhandledRejection', error => {
	console.log('unhandledRejection', error);
	process.exit(1);
});

var tests = {
	decodeVertexBuffer: function() {
		var encoded = new Uint8Array([
			0xa0, 0x01, 0x3f, 0x00, 0x00, 0x00, 0x58, 0x57, 0x58, 0x01, 0x26, 0x00, 0x00, 0x00, 0x01,
			0x0c, 0x00, 0x00, 0x00, 0x58, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			0x3f, 0x00, 0x00, 0x00, 0x17, 0x18, 0x17, 0x01, 0x26, 0x00, 0x00, 0x00, 0x01, 0x0c, 0x00,
			0x00, 0x00, 0x17, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		]);

		var expected = new Uint8Array([
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			44, 1, 0, 0, 0, 0, 0, 0, 244, 1, 0, 0,
			0, 0, 44, 1, 0, 0, 0, 0, 0, 0, 244, 1,
			44, 1, 44, 1, 0, 0, 0, 0, 244, 1, 244, 1
		]);

		var result = new Uint8Array(expected.length);
		decoder.decodeVertexBuffer(result, 4, 12, encoded);

		assert.deepEqual(result, expected);
	},

	decodeIndexBuffer16: function() {
		var encoded = new Uint8Array([
			0xe0, 0xf0, 0x10, 0xfe, 0xff, 0xf0, 0x0c, 0xff, 0x02, 0x02, 0x02, 0x00, 0x76, 0x87, 0x56, 0x67,
			0x78, 0xa9, 0x86, 0x65, 0x89, 0x68, 0x98, 0x01, 0x69, 0x00, 0x00,
		]);

		var expected = new Uint16Array([
			0, 1, 2, 2, 1, 3, 4, 6, 5, 7, 8, 9
		]);

		var result = new Uint16Array(expected.length);
		decoder.decodeIndexBuffer(new Uint8Array(result.buffer), 12, 2, encoded);

		assert.deepEqual(result, expected);
	},

	decodeIndexBuffer32: function() {
		var encoded = new Uint8Array([
			0xe0, 0xf0, 0x10, 0xfe, 0xff, 0xf0, 0x0c, 0xff, 0x02, 0x02, 0x02, 0x00, 0x76, 0x87, 0x56, 0x67,
			0x78, 0xa9, 0x86, 0x65, 0x89, 0x68, 0x98, 0x01, 0x69, 0x00, 0x00,
		]);

		var expected = new Uint32Array([
			0, 1, 2, 2, 1, 3, 4, 6, 5, 7, 8, 9
		]);

		var result = new Uint32Array(expected.length);
		decoder.decodeIndexBuffer(new Uint8Array(result.buffer), 12, 4, encoded);

		assert.deepEqual(result, expected);
	},

	decodeFilterReconstructZ8: function() {
		var encoded = new Uint8Array([
			0xa0, 0x01, 0x3f, 0x00, 0x00, 0x00, 0xa5, 0x73, 0x49, 0x01, 0x33, 0x00, 0x00, 0x00, 0xaa, 0xb3,
			0x01, 0x12, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xab, 0x01, 0x00,
		]);

		var expected = new Int8Array([
			12, -85, -94, 0,
			-71, 0, 105, 0,
			127, 0, 0, 1,
			90, -90, 0, 1,
		]);

		var result = new Int8Array(expected.length);
		decoder.decodeGltfBuffer(result, 4, 4, encoded, 0, 1);

		assert.deepEqual(result, expected);
	},

	decodeFilterReconstructZ16: function() {
		var encoded = new Uint8Array([
			0xa0, 0x01, 0x3f, 0x00, 0x00, 0x00, 0xbb, 0x04, 0xf9, 0x01, 0x3f, 0x00, 0x00, 0x00, 0x97, 0xc7,
			0x49, 0x01, 0x33, 0x00, 0x00, 0x00, 0x6a, 0xfc, 0x01, 0x33, 0x00, 0x00, 0x00, 0x44, 0xb5, 0x01,
			0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x5b, 0x2f, 0xcb, 0xde, 0x01, 0x00, 0x00, 0x00,
		]);

		var expected = new Int16Array([
			12123, -8501, -29231, 0,
			-7171, 0, 31973, 0,
			32767, 0, 0, 1,
			23170, -23170, 0, 1,
		]);

		var result = new Int16Array(expected.length);
		decoder.decodeGltfBuffer(new Uint8Array(result.buffer), 4, 8, encoded, 0, 1);

		assert.deepEqual(result, expected);
	},

	decodeFilterReconstructW8: function() {
		var encoded = new Uint8Array([
			0xa0, 0x01, 0x3f, 0x00, 0x00, 0x00, 0xa5, 0x73, 0x49, 0x01, 0x33, 0x00, 0x00, 0x00, 0xaa, 0xb3,
			0x01, 0x12, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xab, 0x01, 0x00,
		]);

		var expected = new Int8Array([
			12, -85, 1, 94,
			-71, 0, 0, 105,
			127, 0, 0, 0,
			90, -90, 1, 0,
		]);

		var result = new Int8Array(expected.length);
		decoder.decodeGltfBuffer(result, 4, 4, encoded, 0, 2);

		assert.deepEqual(result, expected);
	},

	decodeFilterReconstructW16: function() {
		var encoded = new Uint8Array([
			0xa0, 0x01, 0x3f, 0x00, 0x00, 0x00, 0xbb, 0x04, 0xf9, 0x01, 0x3f, 0x00, 0x00, 0x00, 0x97, 0xc7,
			0x49, 0x01, 0x33, 0x00, 0x00, 0x00, 0x6a, 0xfc, 0x01, 0x33, 0x00, 0x00, 0x00, 0x44, 0xb5, 0x01,
			0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x5b, 0x2f, 0xcb, 0xde, 0x01, 0x00, 0x00, 0x00,
		]);

		var expected = new Int16Array([
			12123, -8501, 1, 29231,
			-7171, 0, 0, 31973,
			32767, 0, 0, 0,
			23170, -23170, 1, 0,
		]);

		var result = new Int16Array(expected.length);
		decoder.decodeGltfBuffer(new Uint8Array(result.buffer), 4, 8, encoded, 0, 2);

		assert.deepEqual(result, expected);
	},

	decodeIndexBufferV1: function() {
		var encoded = new Uint8Array([
			0xe1, 0xf0, 0x10, 0xfe, 0x1f, 0x3e, 0x00, 0x0a, 0x00, 0x76, 0x87, 0x56, 0x67, 0x78, 0xa9, 0x86,
			0x65, 0x89, 0x68, 0x98, 0x01, 0x69, 0x00, 0x00,
		]);

		var expected = new Uint32Array([
			0, 1, 2, 2, 1, 3, 0, 1, 2, 2, 1, 5, 2, 1, 4
		]);

		var result = new Uint32Array(expected.length);
		decoder.decodeIndexBuffer(new Uint8Array(result.buffer), 15, 4, encoded);

		assert.deepStrictEqual(result, expected);
	},
};

decoder.ready.then(() => {
	var count = 0;

	for (var key in tests) {
		tests[key]();
		count++;
	}

	console.log(count, 'tests passed');
});
